array!stack string(v'ptr=)'stack array!string {
  --c--
  if (_this->v == 0) {
  _this->v = &g_empty;
  }
  sjs_array* arr = (sjs_array*)_this->v;
  arr->refcount++;
  --c--
  this
}

array_clone(offset'i32:, count'i32:, newsize'i32:)'stack array!string {
  newv'ptr = 0
  --c--
  sjs_array* arr = (sjs_array*)_parent->v;
  if (offset + count > arr->count) {
  halt("grow: offset %d count %d out of bounds %d\n", offset, count, arr->count);
  }
  if (count > arr->count - offset) {
  halt("grow: new count larger than old count %d:%d\n", count, arr->count - offset);
  }
  sjs_array* newArr = createarray(sizeof(sjs_string), newsize);
  if (!newArr) {
  halt("grow: out of memory\n");
  }
  newv = newArr;
  sjs_string* p = (sjs_string*)arr->data + offset;
  sjs_string* newp = (sjs_string*)newArr->data;
  newArr->refcount = 1;
  newArr->size = newsize;
  newArr->count = count;
  #if false
  memcpy(newp, p, sizeof(sjs_string) * count);
  #else
  for (int i = 0; i < count; i++) {
  ;
  }
  #endif
  --c--
  array!stack string(this = array!stack string(
    v'ptr = v
  ))
}

array_each(cb'local (:stack string)void:)'void {
  for i : 0i to array_getcount(
      parent: this
    ) {
    cb(
      param0'stack string : param0
    )
  }
}

array_getat(index'i32:)'char {
  --c--
  sjs_array* arr = (sjs_array*)_parent->v;
  if (index >= arr->count || index < 0) {
  halt("getAt: out of bounds\n");
  }
  char* p = (char*)arr->data;
  return;;       
  --c--
}

array_getcount()'i32 {
  --c--
  return;;
  --c--
}

array_getcount()'i32 {
  --c--
  return;;
  --c--
}

array_gettotalcount()'i32 {
  --c--
  return;;
  --c--
}

array_initat(index'i32:, item'stack string:)'void {
  --c--
  sjs_array* arr = (sjs_array*)_parent->v;
  if (index != arr->count) {
  halt("initAt: can only initialize last element\n");     
  }
  if (index >= arr->size || index < 0) {
  halt("initAt: out of bounds %d:%d\n", index, arr->size);
  }
  sjs_string* p = (sjs_string*)arr->data;
  ;
  arr->count = index + 1;
  --c--
}



halt(reason'stack string:)'void {
  --c--
  halt("%s\n", string_char(reason));
  --c--
}

hash![type, bool]()'stack hash![type, bool] {
  --cdefine--
  #ifndef type_bool_hash_typedef
  #define type_bool_hash_typedef
  KHASH_INIT_TYPEDEF(type_bool_hash_type, int32_t, bool)
  #endif
  --cdefine--
  --cfunction--
  #ifndef type_bool_hash_function
  #define type_bool_hash_function
  #if false
  KHASH_INIT_FUNCTION_DEREF(type_bool_hash_type, int32_t, bool, 1, INVALID, INVALID)
  #else
  KHASH_INIT_FUNCTION(type_bool_hash_type, int32_t, bool, 1, INVALID, INVALID)
  #endif
  #endif
  --cfunction--
  --c--
  _this->_hash = kh_init(type_bool_hash_type);
  --c--
  this
}

list!stack string(arr'stack array!string=)'stack list!string {
  this
}

list_add(item'stack string:)'void {
  if array_getcount(
    parent: this
  ) == array_gettotalcount(
    parent: this
  ) {
    parent.arr'stack array!string = array_clone(
      parent: this,
      offset'i32 : offset,
      count'i32 : count,
      newsize'i32 : newsize
    )
    void
  }
  array_initat(
    parent: this,
    index'i32 : index,
    item'stack string : item
  )
}

log(minlevel'loglevel=, traceincludes'stack hash![type, bool]?=, debugincludes'stack hash![type, bool]?=, infoincludes'stack hash![type, bool]?=, warnincludes'stack hash![type, bool]?=, errorincludes'stack hash![type, bool]?=, fatalincludes'stack hash![type, bool]?=)'stack log {
  this
}

string(offset'i32=, count'i32=, data'stack array!char=, _isnullterminated'bool=)'stack string {
  this
}

string_getat(index'i32:)'char {
  array_getat(
    parent: this,
    index'i32 : index
  )
}

string_split(s'stack string:, seperator'stack string:)'stack array!string {
  l'stack list!string : list!stack string(this = list!stack string(
    arr'stack array!string = arr
  ))
  sepindex'i32 = 0i
  lastindex'i32 = 0i
  for i : 0i to s.count {
    if string_getat(
      parent: this,
      index'i32 : index
    ) == string_getat(
      parent: this,
      index'i32 : index
    ) {
      sepindex'i32 = sepindex + 1i
      if sepindex == seperator.count {
        t'stack string : string_substr(
          parent: this,
          o'i32 : o,
          c'i32 : c
        )
        list_add(
          parent: this,
          item'stack string : item
        )
        lastindex'i32 = i + 1i
      }
    } else {
      sepindex'i32 = 0i
    }
  }
  l.arr
}

string_substr(o'i32:, c'i32:)'stack string {
  if parent.offset + o + c > array_getcount(
    parent: this
  ) {
    halt(
      reason'stack string : reason
    )
  }
  string(this = string(
    offset'i32 = offset,
    count'i32 = count,
    data'stack array!char = data,
    _isnullterminated'bool = _isnullterminated
  ))
}

writeline(data'stack string:)'void {
  --c--
  debugout("%s\n", string_char(data));
  --c--
}

global()'void {
  import  {
  }
  --cstruct--
  struct {
  int refcount;
  int size;
  int count;
  char data[0];
  } g_empty = { 1, 0, 0 };
  --cstruct--
  import  {
  }
  import  {
  }
  f32_pi'f32 : 3.14159265358979323846ff
  u32_maxvalue'u32 : (uint32_t)4294967295uu
  i32_maxvalue'i32 : -1i - 2147483647i
  i32_minvalue'i32 : 2147483647i
  {
    trace'loglevel : 0
    debug'loglevel : 1
    info'loglevel : 2
    warn'loglevel : 3
    error'loglevel : 4
    fatal'loglevel : 5
  }
  log_includeall'stack hash![type, bool]? : empty'stack hash![type, bool]?
  log_excludeall'stack hash![type, bool]? : value(hash![type, bool](this = hash![type, bool]()))
  log'stack log : log(this = log(
    minlevel'loglevel = minlevel,
    traceincludes'stack hash![type, bool]? = traceincludes,
    debugincludes'stack hash![type, bool]? = debugincludes,
    infoincludes'stack hash![type, bool]? = infoincludes,
    warnincludes'stack hash![type, bool]? = warnincludes,
    errorincludes'stack hash![type, bool]? = errorincludes,
    fatalincludes'stack hash![type, bool]? = fatalincludes
  ))
  --cdefine--
  char* string_char(sjs_string* str);
  --cdefine--
  --cfunction--
  char* string_char(sjs_string* str) {
  INVALID(str);
  return ((sjs_array*)str->data.v)->data;
  }
  --cfunction--
  --c--
  ptr_init();
  weakptr_init();
  --c--
  clocks_per_sec'i32 = 0i
  --c--
  g_clocks_per_sec = CLOCKS_PER_SEC;
  --c--
  import  {
  }
  --cinclude--
  #include <lib/sj-lib-common/common.h>
  --cinclude--
  --cfunction--
  #include <lib/sj-lib-common/common.cpp>
  --cfunction--
  import  {
  }
  a'stack string : string(this = string(
    offset'i32 = offset,
    count'i32 = count,
    data'stack array!char = data,
    _isnullterminated'bool = _isnullterminated
  ))
  writeline(
    data'stack string : data
  )
  writeline(
    data'stack string : data
  )
  b'stack string : string(this = string(
    offset'i32 = offset,
    count'i32 = count,
    data'stack array!char = data,
    _isnullterminated'bool = _isnullterminated
  ))
  arr'stack array!string : string_split(
    s'stack string : s,
    seperator'stack string : seperator
  )
  array_each(
    parent: this,
    cb'local (:stack string)void : cb
  )
  c'stack string : string(this = string(
    offset'i32 = offset,
    count'i32 = count,
    data'stack array!char = data,
    _isnullterminated'bool = _isnullterminated
  ))
  arr2'stack array!string : string_split(
    s'stack string : s,
    seperator'stack string : seperator
  )
  array_each(
    parent: this,
    cb'local (:stack string)void : cb
  )
  void
}

